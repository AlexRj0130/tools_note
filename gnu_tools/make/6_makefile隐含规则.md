[TOC]

# make

## makefile隐含规则

- 隐含规则：早先约定的，由 make 自动生成的，无需显式写在 makefile 中的规则。
  - 会使用系统变量，例如 `CFLAGS`。
- `模式规则`：用来自定义隐含规则。
- `后缀规则`：也可用来自定义隐含规则
  - 备注：
    - 与模式规则相比，用后缀规则定义隐含规则的限制比较多；
    - 但后缀规则可以保证 makefile 的兼容性。
- [示例6.1](./examples/6.1.sh)：自动推导
- [示例6.2](./examples/6.2.sh)：更进一步的自动推导（不建议使用）

- 注意：
  - 在 make 的 **隐含规则库** 中，每一条隐含规则都有其顺序，优先级越高的越靠前。
    - 这种情况下，可能导致即使显式的指定了依赖（但不给出生成命令），make 也会忽略该条指定
    - 为了避免上述情况，就要把依赖和生成命令一并给出。
  - 运行 make 时使用 `-r`（`--no-builtin-rules`） 选项可以取消所有预设置的隐含规则。
    - 即使使用了 `-r` 选项，只要隐含规则中包含**后缀列表**，那么该隐含规则依然生效。

### 隐含规则一览

1. 编译 C 程序的隐含规则
    - .o 目标的依赖目标会被自动推导为 .c
    - .o 目标的生成命令是 `$(CC) -c $(CPPFLAGS) $(CFLAGS)`
1. 编译 C++ 程序的隐含规则
    - .o 目标的依赖目标会被自动推导为 .cc 或 .C
    - .o 目标的生成命令是 `$(CXX) -c $(CPPFLAGS) $(CFLAGS)`
1. 编译 Pascal 程序的隐含规则（暂略）
1. 编译 Fortan/Ratfor 程序的隐含规则（暂略）
1. 预处理 Fortan/Ratfor 程序的隐含规则（暂略）
1. 编译 Modula-2 程序的隐含规则（暂略）
1. 汇编和汇编预处理的隐含规则
    - .o 目标的依赖目标会被自动推导为 .s
      - 默认使用 as 编译器
      - .o 目标的生成命令是 `$(AS) $(ASFLAGS)`
    - .s 目标的依赖目标会被自动推导为 .S
      - 默认使用 C 预编译器 cpp
      - .s 目标的生成命令是 `$(AS) $(ASFLAGS)`
1. 链接 Object 文件的隐含规则
    - \<n> 目标的依赖目标会被自动推导为 \<n>.o
    - 默认使用 ld 链接器（通过运行 C 的编译器来运行该链接器）
    - \<n> 目标的生成命令是 `$(CC) $(LDFLAGS) <n>.o $(LOADLIBS) $(LDLIBS)`
    - 注意：
      - 该规则对于只有一个源文件的工程有效
      - 该规则也对多个 Object 文件也有效
      - > 所以，如果没有一个**源文件**和目标的名字相关联，那么最好写出该目标的生成规则。
    - 示例：
      ```makefile
      # 在 x.c 、 y.c 和 z.c 都存在时
      x : y.o z.o
      # 隐含规则为
      cc -c x.c -o x.o  # 注意这里 x 依赖了 x.o
      cc -c y.c -o y.o
      cc -c z.c -o z.o
      cc x.o y.o z.o -o x
      rm -f x.o
      rm -f y.o
      rm -f z.o
      ```
1. Yacc C 程序时的隐含规则（暂略）
1. Lex C 程序时的隐含规则（暂略）
1. Lex Ratfor 程序时的隐含规则（暂略）
1. 从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则（暂略）
  
### 隐含规则使用的变量

- 可以通过以下方式改变隐含规则使用的**预先设置**的变量的值
  - 在 makefile 中改变变量的值
  - 通过 make 的命令行选项传入变量的值
  - 在环境变量中改变对应变量的值
  - ==注意：使用 `--no-builtin-variables` 可以使上述修改失效。==

> - 隐含规则中使用的变量可以分为两种，分别是：
>   - 命令相关
>   - 参数相关

#### 关于命令的变量

- `AR`: ==函数库打包程序==。
  - 默认命令是 ar
- `AS` : ==汇编语言编译程序==。
  - 默认命令是 as
- `CC` : ==C语言编译程序==。
  - 默认命令是 cc
- `CXX` : ==C++语言编译程序==。
  - 默认命令是 g++
- `CO` : 从 RCS文件中扩展文件程序。
  - 默认命令是 co
- `CPP` : ==C程序的预处理器==（输出是标准输出设备）。
  - 默认命令是 $(CC) –E
- `FC` : Fortran 和 Ratfor 的编译器和预处理程序。
  - 默认命令是 f77
- `GET` : 从SCCS文件中扩展文件的程序。
  - 默认命令是 get
- `LEX` : Lex方法分析器程序（针对于C或Ratfor）。
  - 默认命令是 lex
- `PC` : Pascal语言编译程序。
  - 默认命令是 pc
- `YACC` : Yacc文法分析器（针对于C程序）。
  - 默认命令是 yacc
- `YACCR` : Yacc文法分析器（针对于Ratfor程序）。
  - 默认命令是 yacc –r
- `MAKEINFO` : 转换Texinfo源文件（.texi）到Info文件程序。
  - 默认命令是 makeinfo
- `TEX` : 从TeX源文件创建TeX DVI文件的程序。
  - 默认命令是 tex
- `TEXI2DVI` : 从Texinfo源文件创建军TeX DVI 文件的程序。
  - 默认命令是 texi2dvi
- `WEAVE` : 转换Web到TeX的程序。
  - 默认命令是 weave
- `CWEAVE` : 转换C Web 到 TeX的程序。
  - 默认命令是 cweave
- `TANGLE` : 转换Web到Pascal语言的程序。
  - 默认命令是 tangle
- `CTANGLE` : 转换C Web 到 C。
  - 默认命令是 ctangle
- `RM` : ==删除文件命令==。
  - 默认命令是 rm –f

#### 关于参数的变量

> 下述变量如果没有指明默认值，那么默认值为空

- `ARFLAGS` : ==函数库打包程序==AR命令的参数。
  - 默认值是 rv
- `ASFLAGS` : ==汇编语言编译器==参数。（当明显地调用 .s 或 .S 文件时）
- `CFLAGS` : C语言编译器参数。
- `CXXFLAGS` : ==C++语言编译器==参数。
- `COFLAGS` : RCS命令参数。
- `CPPFLAGS` : ==C预处理器参数==。（ C 和 Fortran 编译器也会用到）。
- `FFLAGS` : Fortran语言编译器参数。
- `GFLAGS` : SCCS “get”程序参数。
- `LDFLAGS` : ==链接器==参数。（如： ld ）
- `LFLAGS` : Lex文法分析器参数。
- `PFLAGS` : Pascal语言编译器参数。
- `RFLAGS` : Ratfor 程序的Fortran 编译器参数。
- `YFLAGS` : Yacc文法分析器参数。

### 隐含规则链

- 隐含规则链：make 会努力自动推导生成目标的一切方法，期间可能跨越多个中间目标
  - 注意：
    - 隐含规则链中，禁止同一个目标出现两次或以上（防止无限递归）
    - make 会优化一些特殊的隐含规则（如利用编译器避免生成中间目标）
- 中间目标：与一般目标的不同之处在于
  - 除非中间目标不存在，才会引发中间规则
  - 目标生成成功后，会通过 rm -f 命令删除中间目标文件
  - 备注：
    - makefile 中指定的目标或依赖目标不能被作为中间目标
    - 通过伪目标 `.INTERMEDIATE` 可以强制把一个目标声明为中间目标
    - 通过把中间目标设定为伪目标 `.SECONDARY` 的依赖目标，可以避免在目标生成成功后，中间目标被删除
    - 通过把模式生成的中间目标设定为伪目标 `.PRECIOUS` 的依赖目标，可以避免在目标生成成功后，中间目标被删除

### 定义模式规则

> 通过使用模式规则可以自定义隐含规则。

- 定义模式规则：
  - 与一般的规则类似，只是在定义目标时需要有 `%` 字符
    - `%` 表示一个或多个任意字符；
    - 在依赖目标中也可以使用 `%` 字符，其值取决于对应的目标中 `%` 所表示的值。
    - 备注：
      - `%` 的展开发生在变量和函数展开之后
      - 变量和函数的展开发生在 make 载入 makefile 时
      - 模式规则中的 `%` 则发生在运行时。
- 示例：把所有的 .c 文件编译成 .o 文件
  ```makefile
  %.o : %.c
    $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
    # $@：表示所有目标的挨个值
    # $<：表示所有依赖目标的挨个值
  ```

#### 自动化变量

- 自动化变量：把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了
  - `$@`：表示规则中的目标文件集。
    - 在模式规则中，如果有多个目标，那么 `$@` 就是匹配与目标中由模式定义的集合。
  - `$%`：仅当目标时函数库文件时，表示规则中的目标成员名。
    - 例如：如果一个目标时 foo.a(bar.o)，那么 `$%` 表示 bar.o；`$@` 表示 foo.a。
  - `$<`：表示依赖目标中的第一个目标的名字。
    - 如果依赖目标是以模式（即 `%`）定义的，那么 `%<` 将是复合模式的一系列的==文件集==
    - 注意：文件集的值是一个一个取出来的
  - `$?`：表示所有比目标新的依赖目标的集合（以空格分隔）
  - `$^`：表示所有的依赖目标的集合（以空格分隔）
    - 备注：如果依赖目标中存在重复的，那么这个变量会去重后只保留一份。
  - `$+`：同 `$^`，但是不会去重。
  - `$*`：表示目标模式中 `%` 及其之前的部分。
    - 例如：如果目标时 dir/a.foo.b，并且目标模式是 a.%.b，那么 `$*` 的值为 dir/a.foo
    - 备注：
      - 该自动化变量能够有效地构建文件名（不包括拓展名）
      - GNU make 具有该特性，其他 make 可能不兼容。
  - 备注：
    - 自动化变量只应出现在==规则的命令==中；
    - 展开时，`$@`, `$%`, `$<`, `$*` 的值代表一个文件；而 `$?`, `$^`, `$+` 代表多个文件。
- 自动化变量与 `D` 和 `F` 含义：
  - `D`：取自动化变量匹配的目标文件路径的目录部分；
  - `F`：取自动化变量匹配的目标文件路径的文件名部分。
  - 示例：如果 `$(@)` 的值为 dir/foo.o
    - `$(@D)`：为 dir
    - `$(@F)`：为 foo.o

#### 模式的匹配

- 茎：在定义好的模式中，由 `%` 所匹配的内容和文件路径中的目录部分；
  - 匹配过程：
    - 识别文件路径中的目录部分与文件名；
    - 使用文件路径中的文件名与模式进行匹配；
    - 匹配成功后，把文件路径和 `%` 匹配的内容作为茎。
- 茎的传递：被依赖目标的 `%` 所匹配的内容传递给目标的 `%`。
  - 示例：当前目录下的文件，src/eat；被依赖目标的模式，`e%t`；目标的模式：`c%r`
    - 识别文件的目录部分为 src/，文件名部分为 eat
    - 使用模式 `e%t` 匹配文件名，得到 `%` 匹配的部分为 `a`
    - 得到茎为：src/ 和 `a`
    - 使用 `%` 匹配的内容替换目标模式中的 `%`，得到 car
    - 合并茎的目录部分，得到 src/car

#### 重载內建隐含规则

- 重载內建隐含规则：定义一个目标和依赖目标与內建隐含规则相同的规则，并自定义规则下的命令
  - 示例：
    ```makefile
    %.o : %.c
        $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
    ```
- 取消內建隐含规则：定义一个目标和依赖目标与內建隐含规则相同的规则，并且不给出规则下的命令
  - 示例
    ```makefile
    %.o : %.s
    ```

### 后缀规则

- 后缀规则：一种老式的定义隐含规则的方法（被模式规则取代）
- 分类：
  - 双后缀规则：定义了一对后缀，即依赖目标的后缀和目标的后缀
    - 示例：
      ```makefile
      .c.o  # 等价于模式规则 %.o : %.c
      ```
  - 单后缀规则：定义了一个后缀，即依赖目标的后缀
    - 示例：
      ```makefile
      .c  # 等价于模式规则 % : %.c
      ```
- 注意：
  - 后缀规则中定义的后缀应该是 make 所认识的
  - ==后缀规则不允许任何的依赖文件==
  - 使用伪目标 `.SUFFIXES` 可以向 make 添加自定义后缀
    - 示例：
      ```makefile
      .SUFFIXES:            # 删除默认的后缀
      .SUFFIXES: .c .o .h   # 定义自己的后缀
      ```
  - make 的 `-r`（`-no-builtin-rules`）选项会使默认的后缀列表为空
  - 变量 `SUFFIXE` 被用来定义默认的后缀列表（不要修改该变量的值，只要用 `.SUFFIXES` 就好）

### 隐含规则搜索算法

> 后缀规则在 makefile 载入内存时会被转换成模式规则，所以无需考虑后缀规则。

- 隐含规则搜索算法示例：目标为 T
  1. 把 T 的目录部分分离出来，记为 D；剩余部分记为 N。
      - 例如：如果 T 是 src/foo.o ，则 D 为 src/ ，N 为 foo.o 
  1. 创建所有匹配于 T 或是 N 的模式规则列表。
  1. 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。
  1. 移除列表中没有命令的规则。
  1. 对于第一个在列表中的模式规则：
      1. 推导其“茎” S
          - S 应该是 T 或是 N 匹配于模式中 % 非空的部分。
      1. 计算依赖文件
          - 把依赖文件中的 % 都替换成“茎” S。
          - 如果目标模式中没有包含斜框字符，则把 D 加在第一个依赖文件的开头。
      1. 测试是否所有的依赖文件都存在或是理当存在。
          - 如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫 “理当存在”
      1. 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。
  1. 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
      1. 如果规则是终止规则，那就忽略它，继续下一条模式规则。
      1. 计算依赖文件。（同第5步）
      1. 测试所有的依赖文件是否存在或是理当存在。
      1. 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
      1. 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。
      1. 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给 T 使用。
- 注意：
  - 如果目标是 `archive(member)`，那么算法可能会执行两次
    - 第一次寻找目标 T
    - 如果没有找到 T，把 `member` 当做 T 再次执行